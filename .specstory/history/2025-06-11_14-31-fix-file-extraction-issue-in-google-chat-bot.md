<!-- Generated by SpecStory -->

# Fix file extraction issue in Google Chat bot (2025-06-11 20:01:17)

_**User**_

I connected the apps script for google chat connection - the code of google chat is - ```/**
 * Google Chat Bot for Document Quotation Processing
 * Connects to FastAPI backend for document processing
 */

// Replace with your actual FastAPI endpoint URL (using EC2 public IP)
const FASTAPI_WEBHOOK_URL = 'http://51.21.187.10:8000/chat-webhook';

/**
 * Main entry point for Google Chat events
 * Routes different event types to appropriate handlers
 */
function onMessage(event) {
  try {
    console.log('Received event:', JSON.stringify(event, null, 2));
    
    // Add authorization token to the event if available
    if (event.token) {
      console.log('Token available in event');
    } else {
      console.log('No token in event - will try to get from context');
      // Try to get token from the execution context
      try {
        const token = ScriptApp.getOAuthToken();
        if (token) {
          event.token = token;
          console.log('Added token to event');
        }
      } catch (e) {
        console.log('Could not get OAuth token:', e.toString());
      }
    }
    
    // Forward the entire event to FastAPI backend
    const response = forwardToFastAPI(event);
    
    if (response) {
      return response;
    } else {
      return {
        "text": "‚ùå Sorry, I couldn't process your request right now. Please try again later."
      };
    }
    
  } catch (error) {
    console.error('Error in onMessage:', error);
    return {
      "text": "‚ùå An error occurred while processing your message. Please try again."
    };
  }
}

/**
 * Handle bot being added to a space
 */
function onAddToSpace(event) {
  try {
    console.log('Bot added to space:', JSON.stringify(event, null, 2));
    
    // Forward to FastAPI backend
    const response = forwardToFastAPI(event);
    
    if (response) {
      return response;
    } else {
      // Fallback response
      const user = event.user || {};
      const space = event.space || {};
      
      let message = "üëã Hello! I'm your Document Quotation Assistant.\n\n";
      
      if (space.singleUserBotDm) {
        message += `Welcome ${user.displayName || 'User'}! `;
      } else {
        message += `Thank you for adding me to ${space.displayName || 'this chat'}! `;
      }
      
      message += "\nüìÑ **How to use me:**\n";
      message += "‚Ä¢ Upload documents (PDF, DOCX, TXT, RTF)\n";
      message += "‚Ä¢ I'll extract content and generate quotations\n";
      message += "‚Ä¢ You'll receive an Excel file with the quotation\n";
      message += "‚Ä¢ Just attach files and mention me!";
      
      return { "text": message };
    }
    
  } catch (error) {
    console.error('Error in onAddToSpace:', error);
    return {
      "text": "üëã Hello! I'm your Document Quotation Assistant. Upload documents to get started!"
    };
  }
}

/**
 * Handle bot being removed from a space
 */
function onRemoveFromSpace(event) {
  console.log('Bot removed from space:', JSON.stringify(event, null, 2));
  
  // Forward to FastAPI for logging
  try {
    forwardToFastAPI(event);
  } catch (error) {
    console.error('Error forwarding removal event:', error);
  }
  
  // No response needed for removal events
  return {};
}

/**
 * Forward the event to FastAPI backend
 * @param {Object} event - The Google Chat event
 * @returns {Object|null} - Response from FastAPI or null if error
 */
function forwardToFastAPI(event) {
  try {
    const payload = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      payload: JSON.stringify(event),
      muteHttpExceptions: true  // Don't throw exceptions on HTTP errors
    };
    
    console.log('Sending to FastAPI:', FASTAPI_WEBHOOK_URL);
    console.log('Event keys:', Object.keys(event));
    
    const response = UrlFetchApp.fetch(FASTAPI_WEBHOOK_URL, payload);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    console.log('FastAPI Response Code:', responseCode);
    console.log('FastAPI Response Text:', responseText);
    
    if (responseCode === 200) {
      try {
        return JSON.parse(responseText);
      } catch (parseError) {
        console.error('Error parsing FastAPI response:', parseError);
        console.error('Response text:', responseText);
        return null;
      }
    } else {
      console.error('FastAPI returned error:', responseCode, responseText);
      return null;
    }
    
  } catch (error) {
    console.error('Error calling FastAPI:', error.toString());
    return null;
  }
}

/**
 * Test function for development
 * Use this to test your webhook locally
 */
function testWebhook() {
  const testEvent = {
    type: 'MESSAGE',
    message: {
      text: 'Hello bot!',
      sender: {
        name: 'users/test-user',
        displayName: 'Test User'
      }
    },
    space: {
      name: 'spaces/test-space',
      type: 'DM',
      singleUserBotDm: true
    },
    user: {
      name: 'users/test-user',
      displayName: 'Test User'
    }
  };
  
  const result = onMessage(testEvent);
  console.log('Test result:', JSON.stringify(result, null, 2));
  return result;
}

/**
 * Test function for file attachment scenario
 */
function testFileUpload() {
  const testEvent = {
    type: 'MESSAGE',
    message: {
      text: 'Process this document please',
      attachment: [{
        name: 'test-document.pdf',
        driveFile: {
          id: 'test-drive-file-id'
        }
      }],
      sender: {
        name: 'users/test-user',
        displayName: 'Test User'
      }
    },
    space: {
      name: 'spaces/test-space',
      type: 'DM',
      singleUserBotDm: true
    },
    user: {
      name: 'users/test-user',
      displayName: 'Test User'
    }
  };
  
  const result = onMessage(testEvent);
  console.log('File upload test result:', JSON.stringify(result, null, 2));
  return result;
}

/**
 * Test the FastAPI connection
 */
function testFastAPIConnection() {
  try {
    const response = UrlFetchApp.fetch('http://51.21.187.10:8000/health');
    console.log('Health check response:', response.getContentText());
    return response.getContentText();
  } catch (error) {
    console.error('Error connecting to FastAPI:', error.toString());
    return null;
  }
}``` but when I am sending file using attach drive files and then uppload I get - ‚ùå No valid text could be extracted from the attached files.
Please ensure files are not corrupted and are in supported formats.. fix it

---

_**Assistant**_

I'll help you fix the issue with file extraction from Google Drive attachments. Looking at the code, I can see that the main issue is in the file download and processing logic. Let me analyze and fix this.

First, let me check the relevant code sections:



---

<details>
            <summary>Searched codebase "download_drive_file_debug function implementation" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `api/main.py` | L284-312 |
| `api/main.py` | L246-284 |
| `api/main.py` | L122-161 |
| `api/main.py` | L187-214 |
| `api/main.py` | L399-417 |
| `api/main.py` | L430-440 |
| `api/main.py` | L385-399 |
| `api/main.py` | L161-187 |
| `api/main.py` | L214-246 |
| `api/main.py` | L440-453 |
| `app.py` | L506-534 |
| `api/main.py` | L345-385 |
| `api/main.py` | L97-122 |
| `api/main.py` | L312-345 |
| `app.py` | L114-129 |
| `app.py` | L582-605 |
| `components/create_excel.py` | L78-97 |
| `app.py` | L357-377 |
| `api/main.py` | L417-426 |
| `components/generate_quotation.py` | L22-42 |
| `api/main.py` | L1-35 |
| `utils.py` | L51-57 |
| `utils.py` | L1-24 |
| `app.py` | L377-408 |
| `components/create_excel.py` | L254-268 |

</details>

---

I see the issue. The current implementation of `download_drive_file_debug` is not properly handling the Google Drive file download. It's currently using a mock implementation that returns test content instead of actually downloading the file. Let me fix this by implementing proper Google Drive file download functionality.

I'll edit the `download_drive_file_debug` function to properly handle Google Drive file downloads:


---

```diff
      
      try:
-         # Method 1: Try using Google Chat API to get file content
-         # This is the proper way for Google Chat bots
-         
-         # Extract possible tokens from the event
-         possible_tokens = []
-         
-         # Check various locations where tokens might be
+         # Get the token from the event
+         token = None
          if "token" in event:
-             possible_tokens.append(("event.token", event["token"]))
-         
-         if "message" in event and "token" in event["message"]:
-             possible_tokens.append(("message.token", event["message"]["token"]))
-             
-         # Check for authorization header in the original request
-         # This would need to be passed from the Apps Script
-         
-         logger.info(f"Found {len(possible_tokens)} possible tokens")
-         
-         # For now, let's try a different approach
-         # Use the Google Chat API to get attachment content
-         
-         # Method 2: Try to use the attachment's downloadUrl if available
+             token = event["token"]
+         elif "message" in event and "token" in event["message"]:
+             token = event["message"]["token"]
+         
+         if not token:
+             logger.error("No authentication token found in event")
+             return None
+             
+         # Get the download URL from the attachment
          message = event.get("message", {})
          attachments = message.get("attachment", [])
```

```diff
                  break
          
-         if target_attachment:
-             logger.info(f"Found target attachment: {json.dumps(target_attachment, indent=2)}")
+         if not target_attachment:
+             logger.error(f"Could not find attachment with file ID: {file_id}")
+             return None
              
-             # Check if there's a downloadUrl or other access method
-             drive_file = target_attachment.get("driveFile", {})
-             if "downloadUrl" in drive_file:
-                 download_url = drive_file["downloadUrl"]
-                 logger.info(f"Found download URL: {download_url}")
-                 
-                 # Try to download using the URL
-                 async with httpx.AsyncClient() as client:
-                     response = await client.get(download_url)
-                     if response.status_code == 200:
-                         logger.info(f"Successfully downloaded via URL: {len(response.content)} bytes")
-                         return response.content
-                     else:
-                         logger.error(f"Download failed with status: {response.status_code}")
-         
-         # Method 3: Create a mock file for testing
-         # This is just for debugging - remove in production
-         logger.warning("Creating mock file content for testing")
-         mock_content = f"This is a test document for {filename}\n\nContent for testing purposes.\n\nThis would normally be the actual file content."
-         return mock_content.encode('utf-8')
-         
+         drive_file = target_attachment.get("driveFile", {})
+         download_url = drive_file.get("downloadUrl")
+         
+         if not download_url:
+             logger.error("No download URL found in attachment")
+             return None
+             
+         # Download the file using the URL and token
+         async with httpx.AsyncClient() as client:
+             headers = {
+                 "Authorization": f"Bearer {token}",
+                 "Accept": "*/*"
+             }
+             
+             response = await client.get(download_url, headers=headers)
+             
+             if response.status_code == 200:
+                 logger.info(f"Successfully downloaded file: {len(response.content)} bytes")
+                 return response.content
+             else:
+                 logger.error(f"Failed to download file. Status code: {response.status_code}")
+                 logger.error(f"Response: {response.text}")
+                 return None
+                 
      except Exception as e:
          logger.error(f"Error downloading Drive file {file_id}: {str(e)}", exc_info=True)
```

---

Now I need to make sure the Apps Script is properly passing the authentication token. Let me check the Apps Script code:


---



---

I apologize for the confusion. I see that I can't directly edit the Apps Script code through the API. Let me provide you with the updated Apps Script code that you should use:

```javascript
function forwardToFastAPI(event) {
  try {
    // Get the OAuth token
    const token = ScriptApp.getOAuthToken();
    
    const payload = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      payload: JSON.stringify(event),
      muteHttpExceptions: true  // Don't throw exceptions on HTTP errors
    };
    
    console.log('Sending to FastAPI:', FASTAPI_WEBHOOK_URL);
    console.log('Event keys:', Object.keys(event));
    
    const response = UrlFetchApp.fetch(FASTAPI_WEBHOOK_URL, payload);
    const responseCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    console.log('FastAPI Response Code:', responseCode);
    console.log('FastAPI Response Text:', responseText);
    
    if (responseCode === 200) {
      try {
        return JSON.parse(responseText);
      } catch (parseError) {
        console.error('Error parsing FastAPI response:', parseError);
        console.error('Response text:', responseText);
        return null;
      }
    } else {
      console.error('FastAPI returned error:', responseCode, responseText);
      return null;
    }
    
  } catch (error) {
    console.error('Error calling FastAPI:', error.toString());
    return null;
  }
}
```

Here's what I've changed:

1. In the FastAPI backend (`api/main.py`):
   - Removed the mock file content generation
   - Added proper token extraction from the event
   - Added proper headers for Google Drive API authentication
   - Improved error handling and logging

2. In the Apps Script:
   - Added proper OAuth token retrieval using `ScriptApp.getOAuthToken()`
   - Added the token to the request headers as `Authorization: Bearer ${token}`

To implement these changes:

1. Update your FastAPI backend with the changes I made to `download_drive_file_debug`
2. Replace your Apps Script's `forwardToFastAPI` function with the code I provided above

Also, make sure that:

1. Your Apps Script project has the necessary Google Drive API scopes enabled:
   - Go to your Apps Script project
   - Click on "Project Settings" (gear icon)
   - Under "Script Properties", add these OAuth scopes:
     - `https://www.googleapis.com/auth/drive.readonly`
     - `https://www.googleapis.com/auth/chat.bot`

2. Your FastAPI server is properly configured to handle CORS and accept the Authorization header:
   ```python
   app.add_middleware(
       CORSMiddleware,
       allow_origins=["*"],
       allow_credentials=True,
       allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
       allow_headers=["*"],
   )
   ```

These changes should fix the file download issue. The system will now:
1. Get a proper OAuth token from Google Apps Script
2. Pass that token to the FastAPI backend
3. Use the token to authenticate with Google Drive API
4. Download the actual file content instead of using mock data

Try uploading a file again after making these changes. You should see proper file downloads and text extraction working.

---

